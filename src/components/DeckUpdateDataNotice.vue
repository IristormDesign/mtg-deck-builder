<template>
	<div v-if="deckDataOutdated" class="wrap">
		<aside class="outdated-deck-data-notice">
			<template v-if="!updatingDeckData">
				<p>⚠ This deck uses an outdated set of card data. Update it to get enhanced app features!</p>
				<div
					v-if="!updatingDeckData"
					class="button-container"
				>
					<button @click="allowDataUpdate()">Update</button>
				</div>
			</template>
			<template v-else>
				<p>Updating now, please wait&hellip;</p>
				<p>Progress: <strong class="updated-percentage">{{ (totalCardsUpdated / combinedDeckTotals * 100).toFixed(0) }}%</strong></p>
			</template>
		</aside>
	</div>
</template>

<script>
import requestScryfallData from '@/mixins/requestScryfallData.js'

export default {
	mixins: [requestScryfallData],
	data () {
		return {
			oldCardQty: 0,
			totalCardsUpdated: 0,
			updatingDeckData: false
		}
	},
	props: {
		deck: Object
	},
	computed: {
		combinedDeckTotals () {
			return this.deck.cards.length + this.deck.sideboard.cards.length
		},
		deckDataOutdated () {
			return this.deck.dataVersion < 2
		}
	},
	created () {
		this.determineDeckDataVersion()
	},
	methods: {
		/**
		 * Check whether any `card` object includes the `keywords` key (even if it's set to no value). Card objects generated by older versions of the app are missing the `keywords` key, as well as `power` and `toughness` keys simultaneously, and so certain parts of the app won't be able to work properly.
		 */
		determineDeckDataVersion () {
			const deck = this.deck

			if (!deck.dataVersion || this.deckDataOutdated) {
				const haveKeywordsObjectKey = () => {
					for (let i = 0; i < deck.cards.length; i++) {
						if (!deck.cards[i].keywords) {
							return 1
						}
					}
					return 2

					// No need to bother checking the sideboard's cards for the `keywords` object key, because the sideboard was released after `keywords`.
				}

				deck.dataVersion = haveKeywordsObjectKey()

				this.$nextTick(() => {
					this.$store.commit('setDecks', this.$store.state.decks)
				})
			}
		},
		allowDataUpdate () {
			if (this.combinedDeckTotals > 150) {
				alert('⚠ Sorry, this deck’s data cannot be updated because it has too many cards.')
			} else {
				console.clear()

				this.$store.commit('setShowSideboard', false)
				this.updateCardGroupData(this.deck)
				this.updatingDeckData = true
			}
		},
		updateCardGroupData (group) {
			const callback = () => {
				this.totalCardsUpdated++
			}

			for (let i = 0; i < group.cards.length; i++) {
				setTimeout(() => {
					this.oldCardQty = group.cards[i].qty

					this.requestScryfallData(group.cards[i].name, callback())

					if (this.totalCardsUpdated === this.deck.cards.length) { // Once all the cards in the main group have been updated...
						setTimeout(() => {
							this.$store.commit('setShowSideboard', true)
							this.updateCardGroupData(this.deck.sideboard)
						}, 150) // This delay seems to be needed to prevent corrupting the deck's data during the updating process.
					} else if (this.totalCardsUpdated === this.combinedDeckTotals) { // Once all the cards in both the main and sideboard groups have been updated...
						setTimeout(() => {
							this.$router.go(0) // Reload the page
						}, 50)
					}
				}, (i + 1) * 100)
			}
		}
	}
}
</script>

<style lang="scss">
	@import '@/sass/page-deck.scss';
</style>
