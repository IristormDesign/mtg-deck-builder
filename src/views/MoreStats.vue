<template>
	<div class="more-stats content-box wrap">
		<h3>More Deck Statistics</h3>

		<div class="tables">
			<more-stats-colors :deck="deck" :manaSymbol="manaSymbol" />
			<more-stats-mana-values :deck="deck" />
			<more-stats-types :deck="deck" />
			<more-stats-subtypes
				:deck="deck"
				:subtypeNames="subtypeCreaturesNames"
				:subtypeCounts="subtypeCounts"
			>Creature</more-stats-subtypes>
			<more-stats-subtypes
				:deck="deck"
				:subtypeNames="subtypeOtherNames"
				:subtypeCounts="subtypeCounts"
			>Other</more-stats-subtypes>
			<more-stats-rarities :deck="deck" :raritySymbol="raritySymbol" />
			<template v-if="showNewStats">
				<more-stats-keywords :deck="deck" />
				<more-stats-power-toughness :deck="deck" />
			</template>
			<more-stats-misc :deck="deck" />
		</div>

		<aside v-if="!showNewStats" class="outdated-data-notice">
			<p>⚠ Update this deck’s set of card data to see additional deck statistics.</p>
			<p v-if="!updatingDeckData" class="update-button-cont">
				<button @click="updateDeckData" class="primary-btn">Update Data Set</button>
			</p>
			<p v-else class="update-button-cont loading-indicator">
				<em>Updating now&hellip;</em>
			</p>
		</aside>

		<footer>
			<p v-if="deck.sideboard.cards.length >= 1">
				<small>Note: These statistics don’t count cards in the sideboard.</small>
			</p>
			<p>
				<router-link :to="{ name: 'deckMain' }">
					◂ Return to the card list
				</router-link>
			</p>
		</footer>
	</div>
</template>

<script>
import axios from 'axios'
import findRelevantDeck from '@/mixins/findRelevantDeck.js'
import requestScryfallData from '@/mixins/requestScryfallData.js'
import symbolsMarkup from '@/mixins/symbolsMarkup.js'
import MoreStatsColors from '@/components/MoreStatsColors.vue'
import MoreStatsManaValues from '@/components/MoreStatsManaValues.vue'
import MoreStatsTypes from '@/components/MoreStatsTypes.vue'
import MoreStatsSubtypes from '@/components/MoreStatsSubtypes.vue'
import MoreStatsRarities from '@/components/MoreStatsRarities.vue'
import MoreStatsMisc from '@/components/MoreStatsMisc.vue'
import MoreStatsKeywords from '@/components/MoreStatsKeywords.vue'
import MoreStatsPowerToughness from '@/components/MoreStatsPowerToughness.vue'

export default {
	mixins: [findRelevantDeck, requestScryfallData, symbolsMarkup],
	components: { MoreStatsColors, MoreStatsManaValues, MoreStatsTypes, MoreStatsSubtypes, MoreStatsRarities, MoreStatsMisc, MoreStatsKeywords, MoreStatsPowerToughness },
	data () {
		return {
			showNewStats: true,
			subtypeCreaturesNames: [],
			subtypeOtherNames: [],
			subtypeCounts: {},
			updatingDeckData: false
		}
	},
	created () {
		// Check whether any `card` object includes the `keywords` key (even if it's set to no value). Card objects generated by older versions of the app are missing the `keywords` key as well as `power` and `toughness` keys, and so their relevant stats tables won't be able to work properly.
		for (let i = 0; i < this.deck.cards.length; i++) {
			if (!this.deck.cards[i].keywords) {
				this.showNewStats = false
				break
			}
		}
	},
	mounted () {
		this.displaySubtypes()
	},
	computed: {
		deck () {
			const decks = this.$store.state.decks

			for (let i = 0; i < decks.length; i++) {
				const deck = decks[i]
				const currentURL = this.$route.path.toLowerCase()
				const deckPathToCheck = `/deck/${deck.path}/`

				if (currentURL.includes(deckPathToCheck)) {
					return deck
				}
			}

			return null
		}
	},
	methods: {
		displaySubtypes () {
			const allSubtypesCreatures = []
			const allSubtypesOther = []
			const subtypeCounts = this.subtypeCounts

			this.deck.cards.forEach(card => {
				for (let i = 0; i < card.qty; i++) {
					const typeLine = card.type

					// Find the pattern that indicates the card is double-faced, which is a space, a slash, a space, and any characters afterward in the card's type line. (This doesn't look at the second face's entire type line.)
					const isDoubleFaced = typeLine.match(/\s\/\s\w*/)

					if (isDoubleFaced) {
						// Get the part of the string that precedes the slash character.
						const firstFace = typeLine.match(/[^/]*/)[0]

						// Get the part of the string that follows the slash character.
						const secondFace = typeLine.match(/\/.*/)[0]

						getSubtypesPerFace(firstFace)
						getSubtypesPerFace(secondFace)
					} else { // A regular single-face card.
						getSubtypesPerFace(typeLine)
					}
				}
			})

			function getSubtypesPerFace (cardFace) {
				// In each card's type line, get only the part that indicates the subtype: the em dash and all characters after it.
				const subtypesPattern = cardFace.match(/\s—\s.*/)

				// Ignore the following only if the card has no subtype.
				if (subtypesPattern) {
					// The card's line of subtypes, which may have only a single subtype or multiple of them.
					const subtypeLine = subtypesPattern[0]

					if (subtypeLine) {
						// Delete the " — " (em dash) part that came from the collected subtype pattern.
						subtypeLine.replace(' — ', '')

						// Get every single subtype in the subtype lines having multiple subtypes. Duplicate single subtypes are included.
						const isolatedSubtypes = subtypeLine.match(/\w+/g)

						// Put all of these isolated subtypes in the `subtypes` array.
						isolatedSubtypes.forEach(subtype => {
							const regexCreatureType = /\bCreature\b/

							if (regexCreatureType.test(cardFace)) {
								allSubtypesCreatures.push(subtype)
							} else {
								allSubtypesOther.push(subtype)
							}
						})
					}
				}
			}

			prepareSubtypesTable(allSubtypesCreatures, this.subtypeCreaturesNames)
			prepareSubtypesTable(allSubtypesOther, this.subtypeOtherNames)

			function prepareSubtypesTable (allSubtypes, subtypeNames) {
				// Make an array containing only the UNIQUE names among all the deck's subtypes.
				allSubtypes.forEach(subtype => {
					if (subtypeNames.indexOf(subtype) < 0) {
						subtypeNames.push(subtype)
					}
				})

				// Alphabetize the subtypes.
				subtypeNames.sort()

				// Set up an object having properties of the unique names of each subtype, with the count of each initially set to 0.
				subtypeNames.forEach(name => {
					subtypeCounts[name] = 0
				})

				// Apply the counts of each subtype.
				allSubtypes.forEach(subtype => {
					for (const name in subtypeCounts) {
						if (subtype === name) {
							subtypeCounts[subtype]++
						}
					}
				})
			}
		},
		updateDeckData () {
			const cards = this.deck.cards
			let cardUpdatesDone = 0

			function callback () {
				cardUpdatesDone++
			}

			if (cards.length > 200) {
				alert('⚠ Sorry, this deck cannot be updated because it has too many cards.')
			} else {
				this.updatingDeckData = true

				for (let i = 0; i < cards.length; i++) {
					const card = cards[i]

					setTimeout(() => {
						this.requestScryfallData(
							card.name, axios, this.deck, card, callback()
						)

						if (cardUpdatesDone === cards.length) {
							setTimeout(() => {
								this.$router.go(0) // Reload the page
							}, 100) // Add a little extra time to let the user's CPU work with the updated card values before reloading the page.
						}
					}, 100 * i)
				}
			}
		}
	}
}
</script>

<style lang="scss">
	@import '@/sass/page-more-stats.scss';
</style>
